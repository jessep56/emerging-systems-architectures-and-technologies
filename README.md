# emerging-systems-architectures-and-technologies

This project involved creating a prototype of a smart thermostat using the TI CC3220x LAUNCHXL development board. The goal was to build a system that could read ambient temperature data from a TMP006 sensor via I2C, control an LED based on temperature settings, detect button presses for adjusting the set temperature, and transmit data via UART as a simulation of server communication. The project solved the problem of building a low-level embedded system to demonstrate the core functionality of a smart thermostat, providing a foundation for future expansion into cloud-connected devices.

Throughout the project, I believe I did particularly well in organizing the task scheduler to manage multiple timed actions—temperature reading, button checking, LED control, and UART transmission. I also prioritized clean, modular code to keep each function focused, which made the code more maintainable and readable.
One area where I could improve is my approach to debugging hardware-related issues. Some errors were challenging to isolate due to hardware dependencies, and I had to learn to use debugging tools and techniques more effectively. Gaining more experience with debugging embedded systems would speed up future projects.

To support my work, I added several tools and resources to my support network, including TI’s Code Composer Studio for development, the draw.io tool for diagramming the task scheduler, and online documentation on embedded systems, UART communication, and I2C protocols.
Several skills from this project are transferable to other embedded systems projects, especially my work with task scheduling, interrupt handling, and interfacing with sensors and communication modules. Understanding how to set up and manage multiple components to work cohesively is critical in embedded systems and IoT development, and this project reinforced those skills.

To make this project maintainable, readable, and adaptable, I applied coding best practices such as using descriptive naming conventions, organizing the code into clear sections, and documenting the functionality of each function. I also created a task scheduler diagram to provide a visual reference, making it easier to understand the overall workflow. This approach ensures that future modifications, such as adding new sensors or adjusting timing intervals, can be implemented with minimal disruption to the existing code structure.
